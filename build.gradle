// Build library: gradlew build
// Install library locally for development with: gradlew install

plugins {
    id 'java'
    id 'maven-publish'
    id 'com.enonic.defaults' version '2.0.1'
    id 'com.enonic.xp.base' version '3.1.0'
    id "com.github.node-gradle.node" version "3.2.1"
}

dependencies {
    compileOnly "com.enonic.xp:core-api:${xpVersion}"

	//compile "com.enonic.xp:lib-context:${xpVersion}"
    compile "com.enonic.xp:lib-io:${xpVersion}"
	//compile "com.enonic.xp:lib-node:${xpVersion}"
    compile "com.enonic.xp:lib-portal:${xpVersion}"
	//compile "com.enonic.xp:lib-repo:${xpVersion}"
	compile "com.enonic.xp:lib-task:${xpVersion}"

    compile 'com.enonic.lib:lib-cache:2.1.1'
    compile 'com.enonic.lib:lib-static:1.0.2'

    compile group: 'org.jdom', name: 'jdom', version: '2.0.2'
    compile group: 'org.json', name: 'json', version: '20220320'
    compile group: 'jaxen', name: 'jaxen', version: '1.2.0'

    implementation 'org.apache.commons:commons-pool2:2.11.1'

    testCompile "com.enonic.xp:testing:${xpVersion}"
}

/*node {
    download = true
    version = '10'
}*/

processResources {
  exclude '**/.gitkeep'
  exclude '**/*.es6'
  exclude '**/*.ts'
}

repositories {
    mavenLocal()
    mavenCentral()
    xp.enonicRepo()
}

tasks.withType(Copy) {
  includeEmptyDirs = false
}

def BUILD_ENV = "production"
if (project.hasProperty("dev") || project.hasProperty("development")) {
    BUILD_ENV = "development"
}


task rollup(type: NpmTask) {
	mustRunAfter(processResources)
	args = ['run', 'rollup']
}
jar.dependsOn(rollup)


if (BUILD_ENV == 'development') {
    task nsiInstall(type: NpmTask) {
        println "BUILD_ENV is set to '" + BUILD_ENV + "':\nOVERRIDING VANILLA npmInstall IN FAVOR OF node-safe-install (nsi)." // Because nsi retains 'npm link' symlinks!
        args = ['run', 'install:nsi']
    }
    npmInstall.enabled = false
    npmInstall.dependsOn nsiInstall
    nsiInstall.inputs.files("package.json", "package-lock.json")
    nsiInstall.outputs.dir("node_modules")
    nsiInstall.outputs.file file("package-lock.json")
} else {
    npmInstall.inputs.files("package.json", "package-lock.json")
    // npmInstall.outputs.dir("node_modules")
    npmInstall.outputs.file file("package-lock.json")
	rollup.dependsOn(npmInstall)
}


//def ROOT = project.projectDir.toString()
//jar.outputs.dir('build/libs')

//////////////////////////////////////////////////  Auto-update current version in docs and package.json:

import groovy.json.JsonSlurper
import groovy.json.JsonOutput

def PACKAGE_JSON = new JsonSlurper().parseText(file('package.json').text)
def LIB_VERSION = "${project.version}"
def PREVIOUS_VERSION = "${PACKAGE_JSON.version}"
def README_SOURCE = "README.src.md"

task makeAdoc(type: Copy) {
    from("./")
    into("./")
    include("README.md")
    rename("README.md", "README.adoc")

    doFirst {
        new File('README.adoc').delete()
    }

    filter {
        String line -> line
                .replaceAll(/\[\/\/\]: <> \((.*?)\)/, "// \$1") // Top comment
                .replaceAll(/^# (.*?)$/, "= \$1\n:toc: right") // Main header, adding auto ToC
                .replaceAll(/^## (.*?)$/, "== \$1") // H2-H5
                .replaceAll(/^### (.*?)$/, "=== \$1")
                .replaceAll(/^#### (.*?)$/, "==== \$1")
                .replaceAll(/^##### (.*?)$/, "===== \$1")
                .replaceAll(/<a name="(.*?)"><\/a>/, "\n[[\$1]]") // Explicit anchor IDs
                .replaceAll(/\[(.*?)\]\((.*?)\)/, "link:\$2[\$1]") // Links
                .replaceAll(/^ +```\s*$/, "----") // Indented code block end (inside numbered list)
                .replaceAll(/^ +```(.*?)$/, "+\n[source,\$1,options=\"nowrap\"]\n----") // Indented code block start (inside numbered list)
                .replaceAll(/^```$/, "----") // Source code end
                .replaceAll(/^```(.*?)$/, "[source,\$1,options=\"nowrap\"]\n----") // Source code start
                .replaceAll(/^(\| ?\*?\*?lib-react4xp\*?\*?[\n \|])(.*?)\|$/, "[%header,cols=2]\n|===\n\$1\$2") // Version table header
                .replaceAll(/^\| ?-.*?- \|$/, "")
                .replaceAll(~ "^(\\| ?\\*?\\*?${LIB_VERSION}.*?)\$", "\$1\n|===") // Version table last line
                .replaceAll(/^(\| ?.*?)\|$/, "\$1") // Version table cells
                .replaceAll(/<br\/>/, "{zwsp} +") // Empty lines
                .replaceAll(/<img src="(.*?)" .*? title="(.*?)" width="(.*?)">/, "image:\$1[title=\"\$2\",width=\$3]") // images
    }

    doLast {
        File fh1 = new File('README.adoc')
        def text = fh1.getText('UTF-8')
        text = text.replaceAll(/\n== Table of Contents\n( *- link:.*?\]\n)*\n/, "")
        fh1.delete()
        fh1.write text
    }
}

task updateReadme(type: Copy) {
    from("./docs/")
    into("./")
    include(README_SOURCE)
    rename(README_SOURCE, "README.md")

    doFirst {
        new File('README.md').delete()
    }

    filter {
        String line -> line
                .replaceAll("USE THIS FILE TO EDIT THE ROOT's README.md! This will be copied to root and and verions inserted before commit. Gradle task: copyReadme. Version placeholders: ###LIB_VERSION###. Leave this line in place", "  DO NOT EDIT! Autogenerated and auto-replaced from source docs/${README_SOURCE}, write docs there instead!  ")
                .replaceAll("###LIB_VERSION###", LIB_VERSION)
    }

    doLast {
        PACKAGE_JSON.version = LIB_VERSION
        def pkgJsonFile = new File('package.json')
        // new File('package.json').delete()
        pkgJsonFile.write(JsonOutput.prettyPrint(JsonOutput.toJson(PACKAGE_JSON)))
    }
}
updateReadme.dependsOn makeAdoc
//npmInstall.dependsOn updateReadme

def readmeUnstaged() {
    def command = "git diff --name-only HEAD"
    // println "Process: ${command}"
    def proc = command.execute()
    proc.waitFor()
    if (proc.exitValue() != 0) {
        throw new GradleException(proc.err.text)
    }
    def stdout = proc.in.text
    def unstagedSource = stdout.split( '\n' ).findAll { it == "docs/README.md" || it == "docs\\README.md" }
    return unstagedSource.size() > 0
}
updateReadme.enabled = true // LIB_VERSION != PREVIOUS_VERSION || readmeUnstaged()
